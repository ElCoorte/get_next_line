Вы теперь начинаете понимать что будет сложно считывать данные с файла если ты
не знаешь заранее его размера. Какого размера будет твой буфер? Как много раз
придется читать файл чтобы извлечь всю инфу?

Это совершенно нормально и естествено что как програмисту тебе захочется
прочитать "линию" которая заканчивается переносом строки в файле. Для примера
каждую команду которую ты вводишь в консоль или каждую линию прочитанную из
файла.

Благодоря проекту get_next_line, ты сможешь написать функцию которая позволит
тебе прочитать линию, которая заканчивается переносом строки, из файла. Вы
сможете добавить эту функцию в свою библиотеку если вам покажется это полезным,
и что более важно, использовать ее в будущих проектах, которые потребуют эту
функцию.

Chapter III

Objectives

Это проект не только позволит добавить очень полезную функцию в вашу колекцию,
но это так же позволит вам выучить очень интересную и новую концепцию в
си-программировании: статические переменные.

Вы также более углубитесь в понимании выделения памяти, которое будут
происходить в стек или в динамическую-память, как манипулировать жизненым циклом
буфера. Неожиданная сложность подразумевается в использовании одной или
нескольких статических переменных.

Ваше следование Нормам позволит увеличить строгость вашей программы. Так же мы
пологаем, что ваш подход к кодингу изменится, когда вы обнаружите, что начальное
состояние переменной в функции может варьироваться в зависимости от вызова этой
самой функции.

Chapter IV

General Instructions

• Ты должен запушить только два файла: get_next_line.c и get_next_line.h
• Если ты умный, ты будешь использовать свою libft. Если да, то оставь libft
    папку в корне репозитория.
• Не должно быть программы main.
• Не должно быть Makefile.
• Твоя программа должна быть написана по НОРМАМ.
• Ты должен обрабатывать ошибки. Ни в коем случае программа не должна выдавать
    (Segmentation fault, bus error, double free, итд).
• Вся выделенная память должна быть очищена когда необходимо.
• Ты должен запушить автор-файл, содержащий твой логин с переносом строки,
    в корневой директории.
• Если ты выберешь пушить этот проект используя свою libft библиотку, это строго
    ЗАПРЕЩЕННО обходить норму добавляя некоторые спецефические функции из своего
    get_next_line. Это считается как читинг при твоей защите. Твой get_next_line
    должен содержать 5 функций по 25 линий максимум. Придерживание этой
    инструкции будет полезно для твоей защиты. Нет необходимости спрашивать
    разрешения у бокала для добовления функции в свою библиотеку. Вместо этого
    используй свою голову и спроси сам себя соблюдает ли эта функция инструкцию.
    Если ты всё сделал правильно это конечно расширит твою библиотеку
    универсальными функциями. Ты обнаружишь их юзабельность когда закончишь этот
    проект.
• Разрешены функции read, malloc и free.

Chapter V

Mandatory part

• Написать функцию которая возвращает линию из файл-дескриптера.
• То что мы называем "Линия" это последовательность символов, которая
    заканчивается переносом строки '\n' или концом файла (EOF).

(Будет полезно для тех кто умеет читать https://latedev.wordpress.com/2012/12/04/all-about-eof/)

• Прототип вашей функции int get_next_line(const int fd, char **line);
• Первый параметр это дескриптр файла, который будет использован для чтения.
• Второй параметр это адрес указателя на символ, который будет использован,
    чтобы сохранить линию, прочитаную с файл-дескриптора.
• Возращаемое число может быть 1, 0 или -1 в зависимости от того, была ли линия
    прочитана, закончилось ли чтение или произошла ошибка, соответсвенно.
• Твоя функция get_next_line должна возвращать результат без переноса строки.
• Вызов твоей функции get_next_line в цикле, позволит считать текст, который
    доступен по дескриптору файла, по одной линии за раз до конца текста.
    Не важен ни размер текста, ни размер какой либо из его линий.
• Будь уверен что твоя функция отрабатывает корректно, когда происходит считает
    из файла, с консоли, с перенаправления (пайпа) и тд кек кто читает лалка сасай.
• В твоем хедр-файле get_next_line.h ты должен иметь как минимум прототип функции
    get_next_line и макрос который позволяет выбрать размер читаемого буфера для
    reed функции. Это число будет изменятся во время защиты для оценки
    защищенности твоей функции. Макрос должен быть назван BUFF_SIZE.
    Для примера #define BUFF_SIZE 32

Твоя функция все еще работает при BUFF_SIZE 9999? и если BUFF_SIZE 1? и 10 000 000 ? знаешь почему?

• Мы учли что get_next_line имеет неопределенное поведение если между двумя
    вызовами одного и того же дескриптор файла он проектирует два отдельных
    файла, хотя чтение из первого файла не было завершено.
• Мы также считаем что вызов lseek(2) не должен происходить между двумя вызовами
    функции get_next_line в одном и том же дискАТЕКАрипторе файла.
• Наконец мы считаем что get_next_line имеет неопределенное поведение когда
    читает из бинарного файла. В любом случае, если ты захочешь, ты можешь
    сделать это поведение корректным.
• Глобальные переменные запрещенно.
• Статические переменные позволено.

Для изучения статических переменных хорошо начать с https:
//en.wikipedia.org/wiki/Static_variable